#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_6,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           lFDrive,       tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           rFDrive,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           lBDrive,       tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port5,           rBDrive,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port6,           lManipulator,  tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port7,           rManipulator,  tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_6)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

void initGyro(){
	SensorType[in1] = sensorNone;
	wait1Msec(1000);
	SensorType[in1] = sensorGyro;
	wait1Msec(2000);
	SensorValue[gyro] = 0;
}

void waitForPress(){
	while(nLCDButtons == 0){}
	wait1Msec(5);
}

void waitForRelease(){
	while(nLCDButtons != 0){}
	wait1Msec(5);
}

void LCDAction(int count){
	switch(count){
		case 0:
			string mainBattery, backupBattery;
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDString(0, 0, "Primary: ");
			sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V');
			displayNextLCDString(mainBattery);
			displayLCDString(1, 0, "Backup: ");
			sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');
			displayNextLCDString(backupBattery);
			waitForPress();
			waitForRelease();
			break;
		case 1:
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDCenteredString(0,"Auton");
			displayLCDCenteredString(1, "Auton");
			waitForPress();
			waitForRelease();
			break;
	}
}

void LCDInteraction(){
		const short leftButton = 1;
		const short centerButton = 2;
		const short rightButton = 4;
		int count = 0;
		bool done = false;
		while(!done){
			switch(count){
				case 0:
					displayLCDCenteredString(0,"Battery Volts");
					displayLCDCenteredString(1, "     Enter     >");
					waitForPress();
					if(nLCDButtons == centerButton){
						waitForRelease();
						LCDAction(count);
					} else if(nLCDButtons == rightButton) {
						waitForRelease();
						count++;
					}
					break;
				case 1:
					displayLCDCenteredString(0,"Choose Auton");
					displayLCDCenteredString(1, "<    Enter     >");
					waitForPress();
					if(nLCDButtons == centerButton){
						waitForRelease();
						LCDAction(count);
					} else if(nLCDButtons == leftButton) {
						waitForRelease();
						count--;
					} else if(nLCDButtons == rightButton) {
						waitForRelease();
						count++;
					}
					break;
				case 2:
					displayLCDCenteredString(0,"Done?");
					displayLCDCenteredString(1, "<    Enter      ");
					waitForPress();
					if(nLCDButtons == centerButton){
						waitForRelease();
						done = true;
					} else if(nLCDButtons == leftButton) {
						waitForRelease();
						count--;
					}
					break;
			}
		}
}

void pre_auton(){
  bStopTasksBetweenModes = true;

  //clear LCD
  bLCDBacklight = true;
  clearLCDLine(0);
	clearLCDLine(1);

  //initialize gyro
	initGyro();

	//Start LCD Interaction
	LCDInteraction();
}

task autonomous(){
  AutonomousCodePlaceholderForTesting();
}

task usercontrol(){
	int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;
	displayLCDCenteredString(0,"Current Heading");
	while(true){
		//Create "deadzone" for Y1/Ch3
		if(abs(vexRT[Ch3]) > threshold){
			Y1 = vexRT[Ch3];
		}else{
			Y1 = 0;
		}
		//Create "deadzone" for X1/Ch4
		if(abs(vexRT[Ch4]) > threshold){
			X1 = vexRT[Ch4];
		}else{
			X1 = 0;
		}
		//Create "deadzone" for X2/Ch1
		if(abs(vexRT[Ch1]) > threshold){
			X2 = vexRT[Ch1];
		}else{
			X2 = 0;
		}

		if(vexRT[Btn6U]){
			motor[lManipulator] = 127;
			motor[rManipulator] = 127;
		} else if(vexRT[Btn6D]){
			motor[lManipulator] = -127;
			motor[rManipulator] = -127;
		} else {
			motor[lManipulator] = 0;
			motor[rManipulator] = 0;
		}

		//Remote Control Commands
		motor[rFDrive] = (Y1 - X2 - X1);
		motor[rBDrive] = (Y1 - X2 + X1);
		motor[lFDrive] = (Y1 + X2 + X1);
		motor[lBDrive] = (Y1 + X2 - X1);

	}
}
