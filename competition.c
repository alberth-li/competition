#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    grabPot,        sensorPotentiometer)
#pragma config(Sensor, in4,    secondaryBatt,  sensorAnalog)
#pragma config(Sensor, dgtl1,  sonar,          sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           lFDrive,       tmotorVex393_MC29, PIDControl, encoderPort, I2C_1)
#pragma config(Motor,  port3,           rFDrive,       tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           topLift,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           midLift,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lBDrive,       tmotorVex393_MC29, PIDControl, encoderPort, I2C_3)
#pragma config(Motor,  port7,           rBDrive,       tmotorVex393_MC29, PIDControl, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port8,           botLift,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           grabber,       tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

//#################
//
//  GLOBAL VARS
//
//#################
int holdAngle;
int grabAngle;
static unsigned char autonomousChoice = 0;

//#################
//
//  GLOBAL CONSTANTS
//
//#################
const float wheelCircumfrence = 4*PI;
const float effectiveCircumfrence = wheelCircumfrence*sqrt(2);
const float ticksPerRev = 627.2;
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

//#################
//
//  FUNCTIONS
//
//#################
//Function to initialize the gyro
void initGyro(){
	SensorType[in1] = sensorNone;
	wait1Msec(1000);
	SensorType[in1] = sensorGyro;
	wait1Msec(2000);
	SensorValue[gyro] = 0;
}

//Function to set all motor encoder values to 0
void zeroEncoders(){
	resetMotorEncoder(lFDrive);
	resetMotorEncoder(lBDrive);
	resetMotorEncoder(rFDrive);
	resetMotorEncoder(rBDrive);
}

//Function to calculate distance that each wheel must move
int moveDistance(int distance){
	return round(ticksPerRev*(distance/effectiveCircumfrence));
}

//Function to set robot to face a different direction based on gyro value
void gyroCorrect(int heading, int power){
	string gyroVal;
	bool brake;
	while(SensorValue[gyro] > heading){
		motor[lFDrive] = -power;
		motor[lBDrive] = -power;
		motor[rFDrive] = power;
		motor[rBDrive] = power;
		sprintf(gyroVal, "%1.0f", SensorValue[gyro]);
		displayLCDCenteredString(0, gyroVal);
		brake = false;
	}
	while(SensorValue[gyro] < heading){
		motor[lFDrive] = power;
		motor[lBDrive] = power;
		motor[rFDrive] = -power;
		motor[rBDrive] = -power;
		sprintf(gyroVal, "%1.0f", SensorValue[gyro]);
		displayLCDCenteredString(0, gyroVal);
		brake = true;
	}
	if(brake){
		motor[lFDrive] = -5;
		motor[lBDrive] = -5;
		motor[rFDrive] = 5;
		motor[rBDrive] = 5;
		wait1Msec(200);
	} else {
		motor[lFDrive] = 5;
		motor[lBDrive] = 5;
		motor[rFDrive] = -5;
		motor[rBDrive] = -5;
		wait1Msec(200);
	}
	stopAllMotors();
}

//Function to wait for an LCD button to be pressed
void waitForPress(){
	while(nLCDButtons == 0){}
	wait1Msec(5);
}

//Function to wait for an LCD button to be released
void waitForRelease(){
	while(nLCDButtons != 0){}
	wait1Msec(5);
}

//Function to act based on LCD choices
void LCDAction(int count){
	switch(count){
		case 0:
			string primaryBattery, secondaryBattery;
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDString(0, 0, "Primary:");
			sprintf(primaryBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V');
			displayNextLCDString(primaryBattery);
			displayLCDString(1, 0, "Secondary:");
			sprintf(secondaryBattery, "%1.2f%c", SensorValue[secondaryBatt]/275.0, 'V');
			displayNextLCDString(secondaryBattery);
			waitForPress();
			waitForRelease();
			break;
		case 1:
			string backupBattery;
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDString(0, 0, "Backup: ");
			sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0,'V');
			displayNextLCDString(backupBattery);
			waitForPress();
			waitForRelease();
			break;
		case 2:
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDCenteredString(0,"Which auton?");
			displayLCDCenteredString(1, " Left     Right ");
			waitForPress();
			if(nLCDButtons == rightButton){
				waitForRelease();
				autonomousChoice = 1;
			} else if(nLCDButtons == leftButton){
				waitForRelease();
				autonomousChoice = 2;
			}
			break;
		case 3:
			clearLCDLine(0);
			clearLCDLine(1);
			initGyro();
			displayLCDCenteredString(0,"Done");
			waitForPress();
			if(nLCDButtons == centerButton){
				waitForRelease();
			}
			break;
	}
}

//Function to use LCD during pre-auton
void LCDInteraction(){
		int count = 0;
		bool done = false;
		while(!done){
			switch(count){
				case 0:
					displayLCDCenteredString(0,"Battery Volts");
					displayLCDCenteredString(1, "     Enter     >");
					waitForPress();
					if(nLCDButtons == centerButton){
						waitForRelease();
						LCDAction(count);
					} else if(nLCDButtons == rightButton) {
						waitForRelease();
						count++;
					}
					break;
				case 1:
					displayLCDCenteredString(0,"Backup Battery");
					displayLCDCenteredString(1, "<    Enter     >");
					waitForPress();
					if(nLCDButtons == centerButton){
						waitForRelease();
						LCDAction(count);
					} else if(nLCDButtons == leftButton) {
						waitForRelease();
						count--;
					} else if(nLCDButtons == rightButton) {
						waitForRelease();
						count++;
					}
					break;
				case 2:
					displayLCDCenteredString(0,"Choose Auton");
					displayLCDCenteredString(1, "<    Enter     >");
					waitForPress();
					if(nLCDButtons == centerButton){
						waitForRelease();
						LCDAction(count);
					} else if(nLCDButtons == leftButton) {
						waitForRelease();
						count--;
					} else if(nLCDButtons == rightButton) {
						waitForRelease();
						count++;
					}
					break;
				case 3:
					displayLCDCenteredString(0,"Init Gyro");
					displayLCDCenteredString(1, "<    Enter     >");
					waitForPress();
					if(nLCDButtons == centerButton){
						waitForRelease();
						LCDAction(count);
					} else if(nLCDButtons == leftButton) {
						waitForRelease();
						count--;
					} else if(nLCDButtons == rightButton) {
						waitForRelease();
						count++;
					}
					break;
					case 4:
						displayLCDCenteredString(0,"Done?");
						displayLCDCenteredString(1, "<    Enter      ");
						waitForPress();
						if(nLCDButtons == centerButton){
							waitForRelease();
							done = true;
						} else if(nLCDButtons == leftButton) {
							waitForRelease();
							count--;
						}
						break;
			}
		}
}

//##############
//
//  TASKS
//
//##############
//Task to keep arm at a chosen angle
task holdArm(){
	while(true){
		if(SensorValue[liftPot] < holdAngle){
			motor[topLift] = 10;
			motor[midLift] = 10;
			motor[botLift] = 10;
		} else if(SensorValue[liftPot] > holdAngle){
			motor[topLift] = -10;
			motor[midLift] = -10;
			motor[botLift] = -10;
		} else {
			motor[topLift] = 0;
			motor[midLift] = 0;
			motor[botLift] = 0;
		}
	}
}

task openGrabber(){
	while(true){
		if(SensorValue[grabber] < grabAngle){
			motor[grabber] = 100;
		} else if(SensorValue[grabber] > grabAngle) {
			motor[grabber] = -100;
		} else {
			motor[grabber] = 0;
		}
	}
}

void pre_auton(){
  bStopTasksBetweenModes = true;

  //clear LCD
  bLCDBacklight = true;
  clearLCDLine(0);
	clearLCDLine(1);

  //initialize gyro
	initGyro();

	//Reset I2C values
	SensorValue[I2C_1] = 0;
	SensorValue[I2C_2] = 0;

	//Start LCD Interaction
	LCDInteraction();
}

task autonomous(){
	SensorValue[sonar] = 0;
	string sonarVal;
	zeroEncoders();
	clearLCDLine(0);
	clearLCDLine(1);
  switch (autonomousChoice){
  	//RIGHT AUTON
  	case 1:
  		//initGyro();
  		grabAngle = 1750;
			startTask(openGrabber);
			stopAllMotors();
  		while(SensorValue[sonar] < 35){
  			motor[lBDrive] = 80;
  			motor[lFDrive] = 80;
  			motor[rBDrive] = 80;
  			motor[rFDrive] = 80;
  			sprintf(sonarVal, "%1.0f", SensorValue[sonar]);
				displayLCDCenteredString(0, sonarVal);
  		}
  		motor[lBDrive] = -10;
  		motor[lFDrive] = -10;
  		motor[rBDrive] = -10;
  		motor[rFDrive] = -10;
  		wait1Msec(300);
  		stopAllMotors();
  		gyroCorrect(0,20);
			stopAllMotors();
			zeroEncoders();
			moveMotorTarget(rFDrive, moveDistance(-5), 80, true);
  		moveMotorTarget(rBDrive, moveDistance(5), 80, true);
  		moveMotorTarget(lFDrive, moveDistance(5), 80, true);
  		moveMotorTarget(lBDrive, moveDistance(-5), 80, true);
  		while(!getMotorTargetCompleted(rFDrive) || !getMotorTargetCompleted(rBDrive) || !getMotorTargetCompleted(lFDrive) || !getMotorTargetCompleted(lBDrive)){}
  		wait1Msec(300);
  		//Lift arm
  		while(SensorValue[liftPot]<1450){
  			motor[topLift] = 127;
				motor[midLift] = 127;
				motor[botLift] = 127;
			}
			holdAngle = 1450;
			startTask(holdArm);
			while(SensorValue[sonar] < 52){
  			motor[lBDrive] = 80;
  			motor[lFDrive] = 80;
  			motor[rBDrive] = 80;
  			motor[rFDrive] = 80;
  			sprintf(sonarVal, "%1.0f", SensorValue[sonar]);
				displayLCDCenteredString(0, sonarVal);
  		}
  		while(SensorValue[sonar] > 50){
  			motor[lBDrive] = -80;
  			motor[lFDrive] = -80;
  			motor[rBDrive] = -80;
  			motor[rFDrive] = -80;
  			sprintf(sonarVal, "%1.0f", SensorValue[sonar]);
				displayLCDCenteredString(0, sonarVal);
  		}
  		stopTask(holdArm);
  		gyroCorrect(0,20);
			zeroEncoders();
			moveMotorTarget(rFDrive, moveDistance(49), 80, true);
  		moveMotorTarget(rBDrive, moveDistance(-49), 80, true);
  		moveMotorTarget(lFDrive, moveDistance(-49), 80, true);
  		moveMotorTarget(lBDrive, moveDistance(49), 80, true);
  		while(!getMotorTargetCompleted(rFDrive) || !getMotorTargetCompleted(rBDrive) || !getMotorTargetCompleted(lFDrive) || !getMotorTargetCompleted(lBDrive)){}
  		wait1Msec(300);
  		//Lift arm
  		while(SensorValue[liftPot]<1150){
  			motor[topLift] = 127;
				motor[midLift] = 127;
				motor[botLift] = 127;
			}
			holdAngle = 1150;
			startTask(holdArm);
			zeroEncoders();
  		moveMotorTarget(rFDrive, moveDistance(4), 80, true);
  		moveMotorTarget(rBDrive, moveDistance(4), 80, true);
  		moveMotorTarget(lFDrive, moveDistance(4), 80, true);
  		moveMotorTarget(lBDrive, moveDistance(4), 80, true);
  		while(!getMotorTargetCompleted(rFDrive) || !getMotorTargetCompleted(rBDrive) || !getMotorTargetCompleted(lFDrive) || !getMotorTargetCompleted(lBDrive)){}
  		wait1Msec(300);
  		zeroEncoders();
  		moveMotorTarget(rFDrive, moveDistance(-4), 80, true);
  		moveMotorTarget(rBDrive, moveDistance(-4), 80, true);
  		moveMotorTarget(lFDrive, moveDistance(-4), 80, true);
  		moveMotorTarget(lBDrive, moveDistance(-4), 80, true);
  		while(!getMotorTargetCompleted(rFDrive) || !getMotorTargetCompleted(rBDrive) || !getMotorTargetCompleted(lFDrive) || !getMotorTargetCompleted(lBDrive)){}
  		wait1Msec(300);
  		stopTask(holdArm);
  		gyroCorrect(0,20);
			zeroEncoders();
			moveMotorTarget(rFDrive, moveDistance(49), 80, true);
  		moveMotorTarget(rBDrive, moveDistance(-49), 80, true);
  		moveMotorTarget(lFDrive, moveDistance(-49), 80, true);
  		moveMotorTarget(lBDrive, moveDistance(49), 80, true);
  		while(!getMotorTargetCompleted(rFDrive) || !getMotorTargetCompleted(rBDrive) || !getMotorTargetCompleted(lFDrive) || !getMotorTargetCompleted(lBDrive)){}
  		wait1Msec(300);
  		//Lift arm
  		while(SensorValue[liftPot]<1450){
  			motor[topLift] = 127;
				motor[midLift] = 127;
				motor[botLift] = 127;
			}
			holdAngle = 1450;
			startTask(holdArm);
			while(SensorValue[sonar] < 52){
  			motor[lBDrive] = 80;
  			motor[lFDrive] = 80;
  			motor[rBDrive] = 80;
  			motor[rFDrive] = 80;
  			sprintf(sonarVal, "%1.0f", SensorValue[sonar]);
				displayLCDCenteredString(0, sonarVal);
  		}
  		while(SensorValue[sonar] > 38){
  			motor[lBDrive] = -80;
  			motor[lFDrive] = -80;
  			motor[rBDrive] = -80;
  			motor[rFDrive] = -80;
  			sprintf(sonarVal, "%1.0f", SensorValue[sonar]);
				displayLCDCenteredString(0, sonarVal);
  		}
  		stopTask(holdArm);
  		stopAllMotors();
  		break;
  	//LEFT AUTON
  	case 2:
			//initGyro();
			while(SensorValue[grabPot]<1700){
				//Open grabber
				motor[grabber] = -100;
			}
			stopAllMotors();
			//Set arm to 2000
  		while(SensorValue[grabPot]>1800){
  			motor[grabber] = 30;
			}
			stopAllMotors();
  		while(SensorValue[sonar] < 35){
  			motor[lBDrive] = 80;
  			motor[lFDrive] = 80;
  			motor[rBDrive] = 80;
  			motor[rFDrive] = 80;
  			sprintf(sonarVal, "%1.0f", SensorValue[sonar]);
				displayLCDCenteredString(0, sonarVal);
  		}
  		motor[lBDrive] = -10;
  		motor[lFDrive] = -10;
  		motor[rBDrive] = -10;
  		motor[rFDrive] = -10;
  		wait1Msec(300);
  		stopAllMotors();
  		gyroCorrect(0,20);
			stopAllMotors();
			zeroEncoders();
			moveMotorTarget(rFDrive, moveDistance(5), 80, true);
  		moveMotorTarget(rBDrive, moveDistance(-5), 80, true);
  		moveMotorTarget(lFDrive, moveDistance(-5), 80, true);
  		moveMotorTarget(lBDrive, moveDistance(5), 80, true);
  		while(!getMotorTargetCompleted(rFDrive) || !getMotorTargetCompleted(rBDrive) || !getMotorTargetCompleted(lFDrive) || !getMotorTargetCompleted(lBDrive)){}
  		wait1Msec(300);
  		//Lift arm
  		while(SensorValue[liftPot]<1450){
  			motor[topLift] = 127;
				motor[midLift] = 127;
				motor[botLift] = 127;
			}
			holdAngle = 1450;
			startTask(holdArm);
			while(SensorValue[sonar] < 52){
  			motor[lBDrive] = 80;
  			motor[lFDrive] = 80;
  			motor[rBDrive] = 80;
  			motor[rFDrive] = 80;
  			sprintf(sonarVal, "%1.0f", SensorValue[sonar]);
				displayLCDCenteredString(0, sonarVal);
  		}
  		while(SensorValue[sonar] > 50){
  			motor[lBDrive] = -80;
  			motor[lFDrive] = -80;
  			motor[rBDrive] = -80;
  			motor[rFDrive] = -80;
  			sprintf(sonarVal, "%1.0f", SensorValue[sonar]);
				displayLCDCenteredString(0, sonarVal);
  		}
  		stopTask(holdArm);
  		gyroCorrect(0,20);
			zeroEncoders();
			moveMotorTarget(rFDrive, moveDistance(-49), 80, true);
  		moveMotorTarget(rBDrive, moveDistance(49), 80, true);
  		moveMotorTarget(lFDrive, moveDistance(49), 80, true);
  		moveMotorTarget(lBDrive, moveDistance(-49), 80, true);
  		while(!getMotorTargetCompleted(rFDrive) || !getMotorTargetCompleted(rBDrive) || !getMotorTargetCompleted(lFDrive) || !getMotorTargetCompleted(lBDrive)){}
  		wait1Msec(300);
  		//Lift arm
  		while(SensorValue[liftPot]<1150){
  			motor[topLift] = 127;
				motor[midLift] = 127;
				motor[botLift] = 127;
			}
			holdAngle = 1150;
			startTask(holdArm);
			/*while(SensorValue[sonar] < 20){
  			motor[lBDrive] = 80;
  			motor[lFDrive] = 80;
  			motor[rBDrive] = 80;
  			motor[rFDrive] = 80;
  			sprintf(sonarVal, "%1.0f", SensorValue[sonar]);
				displayLCDCenteredString(0, sonarVal);
  		}
  		while(SensorValue[sonar] > 11){
  			motor[lBDrive] = -80;
  			motor[lFDrive] = -80;
  			motor[rBDrive] = -80;
  			motor[rFDrive] = -80;
  			sprintf(sonarVal, "%1.0f", SensorValue[sonar]);
				displayLCDCenteredString(0, sonarVal);
  		}*/
  		zeroEncoders();
  		moveMotorTarget(rFDrive, moveDistance(4), 80, true);
  		moveMotorTarget(rBDrive, moveDistance(4), 80, true);
  		moveMotorTarget(lFDrive, moveDistance(4), 80, true);
  		moveMotorTarget(lBDrive, moveDistance(4), 80, true);
  		while(!getMotorTargetCompleted(rFDrive) || !getMotorTargetCompleted(rBDrive) || !getMotorTargetCompleted(lFDrive) || !getMotorTargetCompleted(lBDrive)){}
  		wait1Msec(300);
  		zeroEncoders();
  		moveMotorTarget(rFDrive, moveDistance(-4), 80, true);
  		moveMotorTarget(rBDrive, moveDistance(-4), 80, true);
  		moveMotorTarget(lFDrive, moveDistance(-4), 80, true);
  		moveMotorTarget(lBDrive, moveDistance(-4), 80, true);
  		while(!getMotorTargetCompleted(rFDrive) || !getMotorTargetCompleted(rBDrive) || !getMotorTargetCompleted(lFDrive) || !getMotorTargetCompleted(lBDrive)){}
  		wait1Msec(300);
  		stopTask(holdArm);
  		gyroCorrect(0,20);
			zeroEncoders();
			moveMotorTarget(rFDrive, moveDistance(-49), 80, true);
  		moveMotorTarget(rBDrive, moveDistance(49), 80, true);
  		moveMotorTarget(lFDrive, moveDistance(49), 80, true);
  		moveMotorTarget(lBDrive, moveDistance(-49), 80, true);
  		while(!getMotorTargetCompleted(rFDrive) || !getMotorTargetCompleted(rBDrive) || !getMotorTargetCompleted(lFDrive) || !getMotorTargetCompleted(lBDrive)){}
  		wait1Msec(300);
  		//Lift arm
  		while(SensorValue[liftPot]<1450){
  			motor[topLift] = 127;
				motor[midLift] = 127;
				motor[botLift] = 127;
			}
			holdAngle = 1450;
			startTask(holdArm);
			while(SensorValue[sonar] < 52){
  			motor[lBDrive] = 80;
  			motor[lFDrive] = 80;
  			motor[rBDrive] = 80;
  			motor[rFDrive] = 80;
  			sprintf(sonarVal, "%1.0f", SensorValue[sonar]);
				displayLCDCenteredString(0, sonarVal);
  		}
  		while(SensorValue[sonar] > 38){
  			motor[lBDrive] = -80;
  			motor[lFDrive] = -80;
  			motor[rBDrive] = -80;
  			motor[rFDrive] = -80;
  			sprintf(sonarVal, "%1.0f", SensorValue[sonar]);
				displayLCDCenteredString(0, sonarVal);
  		}
  		stopTask(holdArm);
  		stopAllMotors();
  		break;
  	//DO NO AUTON IN CASE OF EMERGENCY
  	default:
			stopAllMotors();
  		break;
	}
}

task usercontrol(){
	string sens1, sens2;
	int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;
	while(true){
		//Create "deadzone" for Y1/Ch3
		if(abs(vexRT[Ch3]) > threshold){
			Y1 = vexRT[Ch3];
		}else{
			Y1 = 0;
		}
		//Create "deadzone" for X1/Ch4
		if(abs(vexRT[Ch4]) > threshold){
			X1 = vexRT[Ch4];
		}else{
			X1 = 0;
		}
		//Create "deadzone" for X2/Ch1
		if(abs(vexRT[Ch1]) > threshold){
			X2 = vexRT[Ch1];
		}else{
			X2 = 0;
		}


		if(vexRT[Btn6UXmtr2]){
			motor[topLift] = 127;
			motor[midLift] = 127;
			motor[botLift] = 127;
		} else if(vexRT[Btn6DXmtr2]){
			motor[topLift] = -127;
			motor[midLift] = -127;
			motor[botLift] = -127;
		} else if(vexRT[Btn5UXmtr2]){
			motor[topLift] = 90;
			motor[midLift] = 90;
			motor[botLift] = 90;
		} else if(vexRT[Btn5DXmtr2]){
			motor[topLift] = -90;
			motor[midLift] = -90;
			motor[botLift] = -90;
		} else {
			motor[topLift] = 0;
			motor[midLift] = 0;
			motor[botLift] = 0;
		}

		motor[rFDrive] = (Y1 - X2 - X1);
		motor[rBDrive] = (Y1 - X2 + X1);
		motor[lFDrive] = (Y1 + X2 + X1);
		motor[lBDrive] = (Y1 + X2 - X1);

		if(vexRT[Btn8UXmtr2]){
			motor[grabber] = -80;
		} else if(vexRT[Btn8DXmtr2]){
			motor[grabber] = 127;
		} else {
			motor[grabber] = 0;
		}

		sprintf(sens1, "%1.0f", SensorValue[liftPot]);
		sprintf(sens2, "%1.0f", SensorValue[grabPot]);
		displayLCDCenteredString(0, sens1);
		displayLCDCenteredString(1, sens2);
	}
}
